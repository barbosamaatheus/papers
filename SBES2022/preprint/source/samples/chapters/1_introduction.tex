\section{Introdução}
O processo de desenvolvimento de \emph{software} atual, exceto em casos especiais, é feito de forma colaborativa. Em um ambiente colaborativo, é comum que vários desenvolvedores estejam trabalhando em seus ramos individuais (\emph{branches}) simultaneamente, e com frequência incorporem seus códigos a uma versão principal do sistema. No entanto, na prática, o processo de integração de alterações de ramos múltiplos pode ser difícil e propenso a erros, especialmente se as alterações em diferentes ramos entrarem em conflito \cite{Bird2012AssessingTV}, afetando a produtividade da equipe \cite{6915251}.

Alguns desses conflitos requerem a compreensão do comportamento do \emph{software} (conflitos semânticos), e não podem ser detectados por ferramentas atuais de \emph{Merge} como o diff3 \cite{10.5555/1781794.1781836}, podendo levar à introdução de bugs no código, influenciando negativamente na qualidade do produto final.  Horwitz et al.~\cite{Horwitz1989IntegratingNV} especificaram formalmente os conflitos semânticos: duas contribuições advindas de versões \emph{Left} e \emph{Right} para um programa \emph{Base}, originam um conflito semântico se as especificações que as versões se propõem a cumprir em isolado não são satisfeitas na versão integrada \emph{Merge}.\footnote{Versões envolvidas em um \emph{three-way merge}, onde \emph{Base} é o ancestral comum mais recente às duas versões \emph{Left} e \emph{Right}} 
Na prática, não é possível checar a existência dos conflitos semânticos, pois não temos as especificações e não sabemos a intenção real dos desenvolvedores.

Algumas abordagens diferentes já foram utilizadas, como, por exemplo, geração de testes \cite{LeusonSilva2020}, mas essas tendem a apresentar um número alto de falsos negativos, pois verificam se há interferência utilizando valores específicos na execução do código testado.

Também já foram propostos, algoritmos de análise estática para detecção de conflitos semânticos  \cite{InformationFlowRoberto, Binkley95programintegration, Horwitz1989IntegratingNV}, mas esses são baseados em grafos complexos (\emph{System Dependence Graphs} \cite{Horwitz1989IntegratingNV}), e à medida que as bases de código aumentam têm a performance bastante degradada, o que torna essas soluções difíceis de serem aplicadas em bases de código reais de mais de 50 KLOC \cite{InformationFlowRoberto}. Diante disso, surge a necessidade de explorar simplificações dos algoritmos originalmente propostos, de modo a verificar a sua capacidade de detectar os conflitos semânticos com menor custo computacional.

Dessa forma, neste trabalho \rev{implementamos e avaliamos um tipo específico de análise estática para detectar interferências}\footnote{Para detectarmos conflitos, precisaríamos saber a intenção dos desenvolvedores, pois assumimos um conflito como sendo uma interferência não intencional entre mudanças integradas dos desenvolvedores. Desta forma, buscamos detectar uma interferência que é quando o comportamento das mudanças integradas não preserva a intenção das mudanças individuais. Esse trabalho usa o conceito de interferência como aproximação para conflito por não ser possível inferir as intenções dos desenvolvedores.} entre as alterações introduzidas por dois desenvolvedores diferentes, através de uma análise de substituição de atribuição (OA). Consideramos que pode haver OA quando as alterações (adições e modificações) em um dos ramos podem semanticamente (ou seja, sua execução), envolver uma operação de escrita para um elemento de estado que também está associado a uma operação de escrita envolvida nas alterações (adições e modificações) feitas pelo outro ramo, sem operação de escrita da base entre eles.

Para melhor entender o compromisso entre acurácia e eficiência de OA, implementamos uma versão \emph{intraprocedural}, que desconsidera chamadas de método no código analisado e outra \emph{interprocedural}, que  acessa e analisa o corpo das chamadas de método no código analisado.

As implementações da análise proposta (\emph{intraprocedural} e \emph{interprocedural}) foram avaliadas usando um conjunto de 78 cenários de integração de código. Esses cenários foram extraídos de projetos \emph{open-source} Java.

Para cada um dos cenários utilizados foi realizada uma validação manual estruturada para definir o \emph{ground truth} de interferência localmente observável (LOI). Os resultados da execução das análises foram comparados com o \emph{ground truth} para verificar a capacidade das análises em detectar interferências. Por fim, também foram coletadas métricas de precisão, revocação e acurácia usadas para comparar às implementações \emph{intraprocedural} e \emph{interprocedural}. Adicionalmente, também realizamos uma comparação dos resultados com um \emph{ground truth} de OA, buscando identificar o quão próximo as implementações atuais estão de uma implementação ideal.    

Os resultados apontam que as implementações da análise proposta se mostraram capazes de detectar cenários com interferência entre as contribuições, no entanto, teve uma quantidade considerável de falsos negativos. Isso indica que ela não é suficiente para detectar cenários com interferência de forma confiável. Portanto, a análise proposta poderia ser combinada com outras análises para compor uma ferramenta mais robusta para detecção de conflitos de integração semânticos. 